"use strict";(self.webpackChunkmd_note=self.webpackChunkmd_note||[]).push([[6977],{8974:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>h});var r=t(5893),i=t(1151);const a={},s="Cryptography",c={id:"Dotnet/Cryptography/Cryptography",title:"Cryptography",description:"Hash Functions",source:"@site/docs/Dotnet/Cryptography/Cryptography.md",sourceDirName:"Dotnet/Cryptography",slug:"/Dotnet/Cryptography/",permalink:"/my-notes/docs/Dotnet/Cryptography/",draft:!1,unlisted:!1,editUrl:"https://github.com/jishen027/my-notes/tree/main/docs/Dotnet/Cryptography/Cryptography.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Settings for Tailwind CSS with Blazor(.NET 8)",permalink:"/my-notes/docs/Dotnet/Blazor/Settings_for_Tailwindcss_with_Blazor"},next:{title:"CBC MAC encryption for image data",permalink:"/my-notes/docs/Dotnet/Cryptography/CBC_MAC"}},o={},h=[{value:"Hash Functions",id:"hash-functions",level:2},{value:"Encryption and decryption",id:"encryption-and-decryption",level:2},{value:"Symmetric Encryption",id:"symmetric-encryption",level:3},{value:"Symmetric algorithms",id:"symmetric-algorithms",level:2},{value:"Asymmetric Algorithms",id:"asymmetric-algorithms",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"cryptography",children:"Cryptography"}),"\n",(0,r.jsx)(n.h2,{id:"hash-functions",children:"Hash Functions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"One-way function - cannot be reversed"}),"\n",(0,r.jsx)(n.li,{children:"Fixed length output"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public void OnGet()\n{\n  var plainText = "Hello World!";\n\n  // MD5 Hash, create an instance of the MD5 hash algorithm\n  SHA512 hashSvc = SHA512.Create();\n\n  // Compute the hash value, returns a byte array\n  byte[] hash = hashSvc.ComputeHash(Encoding.UTF8.GetBytes(plainText));\n\n  // Convert the byte array to a hexadecimal string, because the hash is a byte array\n  var hex = BitConverter.ToString(hash).Replace("-", "").ToLower();\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"encryption-and-decryption",children:"Encryption and decryption"}),"\n",(0,r.jsx)(n.h3,{id:"symmetric-encryption",children:"Symmetric Encryption"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Encryption and decryption use the same key"}),"\n",(0,r.jsx)(n.li,{children:"Faster than asymmetric encryption"}),"\n",(0,r.jsx)(n.li,{children:"Key management is difficult"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"symmetric-algorithms",children:"Symmetric algorithms"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'.NET Symmetric algorithm are "block ciphers"'}),"\n",(0,r.jsx)(n.li,{children:"Mode : ECB, CBC, CFB, OFB, CTR, GCM"}),"\n",(0,r.jsx)(n.li,{children:"IV (Initialization Vector)"}),"\n",(0,r.jsx)(n.li,{children:"Ramdom value that is used to initialize the encryption algorithm"}),"\n",(0,r.jsx)(n.li,{children:"Does not need to be secret"}),"\n",(0,r.jsx)(n.li,{children:"Must be unique for each message"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public string IV { get; set; }\npublic string CipherText { get; set; }\npublic string OriginalText { get; set; }\n\nprivate Aes CreateCipher()\n{\n  // Create an instance of the AES algorithm\n  Aes cipher = Aes.Create(); // Defaults - KeySize = 256, BlockSize = 128, Mode = CBC, Padding = PKCS7, IV = Random\n\n  // cipher.Padding means that the data is padded to the block size, PaddingMode is a enumeration that specifies the type of padding to apply when the message data block is shorter than the full number of bytes needed for a cryptographic operation.\n  cipher.Padding = PaddingMode.ISO10126;\n\n  // use a constant key for encryption\n  cipher.Key = conversions.HexToByteArray("2B7E151628AED2A6ABF7158809CF4F3C");\n\n  return cipher;\n}\n\npublic async Task<string> OnGetEncryptAsync()\n{\n  Aes cipher = CreateCipher();\n\n  // Encrypt the data\n  IV = Convert.ToBase64String(cipher.IV);\n\n  // Create an encryptor for the cipher to use\n  ICryptoTransform encryptor = cipher.CreateEncryptor();\n\n  byte[] plainText = Encoding.UTF8.GetBytes("Hello World!");\n  // Perform the encryption, returns a byte array, transformFinalBlock is used to process the last block of data\n  byte[] cipherText = encryptor.TransformFinalBlock(plainText, 0, plainText.Length);\n\n  CipherText = Convert.ToBase64String(cipherText);\n\n  return CipherText;\n}\n\npublic async Task<string> OnGetDecryptAsync()\n{\n  Aes cipher = CreateCipher();\n\n  cipher.IV = Convert.FromBase64String(IV);\n\n  ICryptoTransform decryptor = cipher.CreateDecryptor();\n\n  byte[] cipherText = Convert.FromBase64String(CipherText);\n  byte[] plainText = decryptor.TransformFinalBlock(cipherText, 0, cipherText.Length);\n\n  OriginalText = Encoding.UTF8.GetString(plainText);\n\n  return OriginalText;\n}\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"asymmetric-algorithms",children:"Asymmetric Algorithms"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Utilizes two complimentary keys (public and private)\n",(0,r.jsx)(n.img,{alt:"alt text",src:t(3296).Z+"",width:"954",height:"390"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Generally slower than symmetric algorithms"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:'Often use asymmetric to encrypt a "session" symmetric key'}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Abstract base class: RSA, ECDiffieHellman, ECDsa"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'public string OriginalText { get; set; }\npublic string CipherText { get; set; }\npublic string plainText { get; set; }\n\nprivate RSA CreateCipher()\n{\n  // RAS is an abstract class, so we use the Create method to create an instance of the RSA algorithm\n  RSA cipher = RSA.Create(); // Defaults - KeySize = 2048\n\n  // Read the public and private keys from the XML files\n  cipher.FromXmlString(System.IO.File.ReadAllText("rsa-private.xml"));\n\n  return cipher;\n}\n\npublic async Task<string> OnPostEncryptAsync()\n{\n  RSA cipher = CreateCipher();\n\n  // Encrypt the data\n  byte[] data = Encoding.UTF8.GetBytes(plainText);\n  byte[] cipherText = cipher.Encrypt(data, RSAEncryptionPadding.Pkcs1);\n  CipherText = Convert.ToBase64String(cipherText);\n\n  return CipherText;\n}\n\npublic async Task<string> OnPostDecryptAsync()\n{\n  RSA cipher = CreateCipher();\n\n  byte[] cipherText = Convert.FromBase64String(CipherText);\n  byte[] data = cipher.Decrypt(cipherText, RSAEncryptionPadding.Pkcs1);\n  OriginalText = Encoding.UTF8.GetString(data);\n\n  return OriginalText;\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},3296:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/image-adffb734c16ce9369f0dc7234f383350.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>s});var r=t(7294);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);