"use strict";(self.webpackChunkmd_note=self.webpackChunkmd_note||[]).push([[9889],{3766:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var r=t(5893),o=t(1151);const i={},s="Interface Segregation Principle",c={id:"SOLID/Interface_Segregation_Principle",title:"Interface Segregation Principle",description:"- Clients should not be forced to depend upon interfaces that they do not use.",source:"@site/docs/SOLID/Interface_Segregation_Principle.md",sourceDirName:"SOLID",slug:"/SOLID/Interface_Segregation_Principle",permalink:"/my-notes/docs/SOLID/Interface_Segregation_Principle",draft:!1,unlisted:!1,editUrl:"https://github.com/jishen027/my-notes/tree/main/docs/docs/SOLID/Interface_Segregation_Principle.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dependency Inversion Principle",permalink:"/my-notes/docs/SOLID/Dependency_Inversion_Principle"},next:{title:"Liskov Substitution Principle",permalink:"/my-notes/docs/SOLID/Liskov_Substitution_Principle"}},a={},l=[];function d(n){const e={code:"code",h1:"h1",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"interface-segregation-principle",children:"Interface Segregation Principle"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Clients should not be forced to depend upon interfaces that they do not use."}),"\n",(0,r.jsx)(e.li,{children:"The interface-segregation principle (ISP) states that no client should be forced to depend on methods it does not use."}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// Interface Segregation Principle\n// \nclass Printer {\n  constructor() {\n    if (this.constructor.name === "Printer") {\n      throw new Error("Printer is abstract!");\n    }\n  }\n\n  print() {\n    throw new Error("print method is not implemented");\n  }\n}\n\nclass Scanner {\n  constructor() {\n    if (this.constructor.name === "Scanner") {\n      throw new Error("Scanner is abstract!");\n    }\n  }\n\n  scan() {\n    throw new Error("scan method is not implemented");\n  }\n}\n\nclass Fax {\n  constructor() {\n    if (this.constructor.name === "Fax") {\n      throw new Error("Fax is abstract!");\n    }\n  }\n\n  fax() {\n    throw new Error("fax method is not implemented");\n  }\n}\n\nclass MultiFunctionPrinter extends Printer, Scanner, Fax {\n  print() {\n    console.log("print");\n  }\n\n  scan() {\n    console.log("scan");\n  }\n\n  fax() {\n    console.log("fax");\n  }\n}\n\nclass OldFashionedPrinter extends Printer {\n  print() {\n    console.log("print");\n  }\n}\n\n'})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"in the above example, the Printer class is closed for modification, we can add a new printer, such as OldFashionedPrinter, without modifying the Printer class"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"the Printer class is open for extension, we can add a new printer, such as OldFashionedPrinter, by extending the Printer class"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"the Printer class is closed for modification, we can add a new printer, such as OldFashionedPrinter, without modifying the Printer class"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// functional programming - Interface Segregation Principle\n\nconst printer = () => {\n  const print = () => {\n    console.log("print");\n  };\n\n  return { print };\n};\n\nconst scanner = () => {\n  const scan = () => {\n    console.log("scan");\n  };\n\n  return { scan };\n};\n\nconst fax = () => {\n  const fax = () => {\n    console.log("fax");\n  };\n\n  return { fax };\n};\n\nconst multiFunctionPrinter = () => {\n  const print = () => {\n    console.log("print");\n  };\n\n  const scan = () => {\n    console.log("scan");\n  };\n\n  const fax = () => {\n    console.log("fax");\n  };\n\n  return { print, scan, fax };\n};\n\nconst oldFashionedPrinter = () => {\n  const print = () => {\n    console.log("print");\n  };\n\n  return { print };\n};\n'})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"in the above example, the printer function is closed for modification, we can add a new printer, such as oldFashionedPrinter, without modifying the printer function"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// functional programming - Interface Segregation Principle\n\nconst printer = () => {\n  const print = () => {\n    console.log("print");\n  };\n\n  return { print };\n};\n\nconst scanner = () => {\n  const scan = () => {\n    console.log("scan");\n  };\n\n  return { scan };\n};\n\nconst fax = () => {\n  const fax = () => {\n    console.log("fax");\n  };\n\n  return { fax };\n};\n\nconst multiFunctionPrinter = () => {\n  const print = () => {\n    console.log("print");\n  };\n\n  const scan = () => {\n    console.log("scan");\n  };\n\n  const fax = () => {\n    console.log("fax");\n  };\n\n  return { print, scan, fax };\n};\n\nconst oldFashionedPrinter = () => {\n  const print = () => {\n    console.log("print");\n  };\n\n  return { print };\n};\n'})})]})}function p(n={}){const{wrapper:e}={...(0,o.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},1151:(n,e,t)=>{t.d(e,{Z:()=>c,a:()=>s});var r=t(7294);const o={},i=r.createContext(o);function s(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);