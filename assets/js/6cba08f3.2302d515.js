"use strict";(self.webpackChunkmd_note=self.webpackChunkmd_note||[]).push([[8972],{4072:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var a=t(5893),r=t(1151);const i={},s="CBC MAC encryption for image data",d={id:"Dotnet/Cryptography/CBC_MAC",title:"CBC MAC encryption for image data",description:"Overview",source:"@site/docs/Dotnet/Cryptography/CBC_MAC.md",sourceDirName:"Dotnet/Cryptography",slug:"/Dotnet/Cryptography/CBC_MAC",permalink:"/my-notes/docs/Dotnet/Cryptography/CBC_MAC",draft:!1,unlisted:!1,editUrl:"https://github.com/jishen027/my-notes/tree/main/docs/Dotnet/Cryptography/CBC_MAC.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Cryptography",permalink:"/my-notes/docs/Dotnet/Cryptography/"},next:{title:"Applying Migrations",permalink:"/my-notes/docs/Dotnet/EF/ApplyingMigrations"}},o={},c=[{value:"Overview",id:"overview",level:2},{value:"Security Considerations",id:"security-considerations",level:2}];function y(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"cbc-mac-encryption-for-image-data",children:"CBC MAC encryption for image data"}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"This implementation demonstrates CBC-MAC (Cipher Block Chaining Message Authentication Code) for authenticating image data. Key features:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Uses AES-256 in CBC mode for encryption"}),"\n",(0,a.jsx)(n.li,{children:"Generates a MAC from the final ciphertext block"}),"\n",(0,a.jsx)(n.li,{children:"Includes PKCS#7 padding for block alignment"}),"\n",(0,a.jsx)(n.li,{children:"Provides verification with constant-time comparison"}),"\n",(0,a.jsx)(n.li,{children:"Handles both file and byte array inputs"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The MAC is derived from the last ciphertext block"}),"\n",(0,a.jsx)(n.li,{children:"Uses CryptographicOperations.FixedTimeEquals for verification"}),"\n",(0,a.jsx)(n.li,{children:"Proper padding ensures complete blocks"}),"\n",(0,a.jsx)(n.li,{children:"Random IVs should be used for each message"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing System.IO;\nusing System.Security.Cryptography;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string imagePath = "Image/mysql.jpg";\n        string ciphertextPath = "Image/mysql.ciphertext.bin";\n        string macPath = "Image/mysql.mac.bin";\n        string decryptedPath = "Image/mysql.decrypted.jpg";\n        \n        // Generate random key and IV for each encryption\n        using (Aes aes = Aes.Create())\n        {\n            aes.KeySize = 256; // Use 256-bit AES encryption\n            aes.GenerateKey();\n            aes.GenerateIV();\n            \n            // Encrypt the image and get ciphertext + MAC\n            var (ciphertext, mac) = EncryptImage(imagePath, aes.Key, aes.IV);\n            \n            // Store ciphertext and MAC separately\n            File.WriteAllBytes(ciphertextPath, ciphertext);\n            File.WriteAllBytes(macPath, mac);\n            Console.WriteLine($"Ciphertext saved to {ciphertextPath}");\n            Console.WriteLine($"MAC saved to {macPath}");\n            \n            // Read back ciphertext and MAC for verification\n            byte[] storedCiphertext = File.ReadAllBytes(ciphertextPath);\n            byte[] storedMac = File.ReadAllBytes(macPath);\n            \n            // Decrypt the image\n            byte[] decryptedData = DecryptImage(storedCiphertext, aes.Key, aes.IV);\n            File.WriteAllBytes(decryptedPath, decryptedData);\n            Console.WriteLine($"Image decrypted and saved to {decryptedPath}");\n            \n            // Verify using stored MAC\n            byte[] original = File.ReadAllBytes(imagePath);\n            bool verified = VerifyMac(original, aes.Key, aes.IV, storedMac);\n            Console.WriteLine($"MAC verification: {(verified ? "SUCCESS" : "FAILURE")}");\n        }\n    }\n    \n    /// <summary>\n    /// Adds PKCS#7 padding to data to make it block-aligned\n    /// </summary>\n    static byte[] AddPKCS7Padding(byte[] data, int blockSize)\n    {\n        int paddingLength = blockSize - (data.Length % blockSize);\n        if (paddingLength == 0) paddingLength = blockSize;\n        \n        byte[] padded = new byte[data.Length + paddingLength];\n        Array.Copy(data, padded, data.Length);\n        for (int i = data.Length; i < padded.Length; i++)\n        {\n            padded[i] = (byte)paddingLength;\n        }\n        return padded;\n    }\n\n    /// <summary>\n    /// Removes PKCS#7 padding from decrypted data\n    /// </summary>\n    static byte[] RemovePKCS7Padding(byte[] data)\n    {\n        int paddingLength = data[data.Length - 1];\n        if (paddingLength > data.Length) return data; // Invalid padding\n        \n        byte[] unpadded = new byte[data.Length - paddingLength];\n        Array.Copy(data, unpadded, unpadded.Length);\n        return unpadded;\n    }\n\n    /// <summary>\n    /// Encrypts an image file and returns ciphertext + MAC\n    /// MAC is derived from the last ciphertext block\n    /// </summary>\n    static (byte[] ciphertext, byte[] mac) EncryptImage(string filePath, byte[] key, byte[] iv)\n    {\n        byte[] imageData = File.ReadAllBytes(filePath);\n        byte[] paddedData = AddPKCS7Padding(imageData, 16); // AES block size is 16 bytes\n        \n        using (Aes aes = Aes.Create())\n        {\n            aes.Key = key;\n            aes.IV = iv;\n            aes.Mode = CipherMode.CBC;\n            aes.Padding = PaddingMode.None; // We handle padding manually\n            \n            using (MemoryStream ms = new MemoryStream())\n            {\n                using (ICryptoTransform encryptor = aes.CreateEncryptor())\n                using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))\n                {\n                    cs.Write(paddedData, 0, paddedData.Length);\n                    cs.FlushFinalBlock();\n                }\n                \n                byte[] ciphertext = ms.ToArray();\n                // MAC is the last ciphertext block\n                byte[] mac = new byte[aes.BlockSize / 8];\n                Array.Copy(ciphertext, ciphertext.Length - mac.Length, mac, 0, mac.Length);\n                \n                return (ciphertext, mac);\n            }\n        }\n    }\n    \n    /// <summary>\n    /// Decrypts ciphertext using AES-CBC\n    /// </summary>\n    static byte[] DecryptImage(byte[] ciphertext, byte[] key, byte[] iv)\n    {\n        using (Aes aes = Aes.Create())\n        {\n            aes.Key = key;\n            aes.IV = iv;\n            aes.Mode = CipherMode.CBC;\n            aes.Padding = PaddingMode.None; // We handle padding manually\n            \n            using (MemoryStream ms = new MemoryStream())\n            {\n                using (ICryptoTransform decryptor = aes.CreateDecryptor())\n                using (CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write))\n                {\n                    cs.Write(ciphertext, 0, ciphertext.Length);\n                    cs.FlushFinalBlock();\n                }\n                \n                return ms.ToArray();\n            }\n        }\n    }\n    \n    /// <summary>\n    /// Verifies the MAC using constant-time comparison\n    /// </summary>\n    static bool VerifyMac(byte[] data, byte[] key, byte[] iv, byte[] expectedMac)\n    {\n        byte[] encrypted = EncryptImageFromBytes(data, key, iv);\n        byte[] actualMac = new byte[iv.Length];\n        Array.Copy(encrypted, encrypted.Length - iv.Length, actualMac, 0, iv.Length);\n        \n        // Constant-time comparison to prevent timing attacks\n        uint diff = (uint)expectedMac.Length ^ (uint)actualMac.Length;\n        for (int i = 0; i < expectedMac.Length && i < actualMac.Length; i++)\n        {\n            diff |= (uint)(expectedMac[i] ^ actualMac[i]);\n        }\n        \n        return diff == 0;\n    }\n    \n    /// <summary>\n    /// Encrypts raw bytes (used for MAC verification)\n    /// </summary>\n    static byte[] EncryptImageFromBytes(byte[] data, byte[] key, byte[] iv)\n    {\n        byte[] paddedData = AddPKCS7Padding(data, 16); // Ensure proper padding\n        \n        using (Aes aes = Aes.Create())\n        {\n            aes.Key = key;\n            aes.IV = iv;\n            aes.Mode = CipherMode.CBC;\n            aes.Padding = PaddingMode.None;\n            \n            using (ICryptoTransform encryptor = aes.CreateEncryptor())\n            using (MemoryStream ms = new MemoryStream())\n            {\n                using (CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))\n                {\n                    cs.Write(paddedData, 0, paddedData.Length);\n                }\n                return ms.ToArray();\n            }\n        }\n    }\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(y,{...e})}):y(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>d,a:()=>s});var a=t(7294);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);